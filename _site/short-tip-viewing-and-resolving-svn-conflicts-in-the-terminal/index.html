<article itemprop="blogPosts" itemscope itemtype="https://schema.org/BlogPosting">
  <meta itemprop="datePublished" content="2015-06-15T12:00:00+03:00">
  <meta itemprop="dateModified" content="2015-06-15T12:00:00+03:00">
  <meta itemprop="keywords" content="svn, workflow, automation, subversion, sublimetext, st3, terminal, iterm2">
  
    <meta itemprop="inLanguage" content="en_US">
  

  <h1 itemprop="headline">Short tip: viewing and resolving svn conflicts in the terminal</h1>
  <time itemProp="datePublished" datetime="2015-06-15T12:00:00+03:00">15 Jun 2015</time>

   <main itemprop="articleBody">
    <p>Working with SVN for the past couple of years has taught me a lot in terms of how I don’t want a version control system to be. Unfortunately, many of the customers and companies I’ve worked with/for have had their entire codebase on SVN, and very often I’ve found myself in the situation where, after a simple merge, I’d get tons of conflicts, either related to whitespace, or a specific piece of code that changes between releases (app version, for example).</p>

<p>Now, to clarify: I’m not an IDE guy, and even though I’ve used many IDEs and I still use them today, if I can do my job in Vim, Sublime Text or even Chrome Dev Tools, then I’m good with that. I’m also a big fan of the command line, so when it comes to SVN conflicts, my workflow is as follows:</p>

<p>If I have conflicts, I first list only the conflicted files, so I can have a clear view of the size of the problem. For this, I rely on the fact that SVN adds the state that the file is in, as the first letter on each row, when issuing the <code class="highlighter-rouge">svn status</code> command.</p>

<p><code class="highlighter-rouge">&gt; svn status | grep "^C"</code></p>

<p>The above command pipes <code class="highlighter-rouge">svn status</code> through <code class="highlighter-rouge">grep</code> and applies a RegExp which basically says: “Give me all the rows in <code class="highlighter-rouge">svn status</code>’s output that begin with a capital C”. The output will look the same as below.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>adrian at mothership <span class="k">in</span> ~/Documents/projects/svn-project
<span class="gp">&gt; </span>svn st | grep <span class="s2">"^C"</span>
C       modules/user/index.js
C       modules/user/meta_inf.json
C       modules/database/index.js
C       modules/database/drivers/cassandra.js
C       modules/database/drivers/redis.js
C       package.json
</code></pre>
</div>

<p>I then open all conflicted files in an editor, in this case Sublime Text 3 with the following command:</p>

<p><code class="highlighter-rouge">&gt; subl $(svn status | grep "^C" | awk '{print $2}'</code></p>

<p>I’ll break the command into subcommands so I can explain what each subcommand does. I’ll asume we already know the grepping part, so I’ll explain only the <code class="highlighter-rouge">awk</code> part.</p>

<p><code class="highlighter-rouge">&gt; svn status | grep "^C" | awk '{print $2'}</code> means: “Take the output of <code class="highlighter-rouge">svn status</code> and pipe it through <a href="https://en.wikipedia.org/wiki/AWK">awk’s</a> <code class="highlighter-rouge">print</code> statement”.</p>

<p>Given the fact that we have 2 columns in our initial <code class="highlighter-rouge">svn status</code> output — the Cs column and the filename column — we can rely on awk to print the filename for us for each row in the output it receives. If you would issue the subcommand above in your terminal you’d get the list of conflicted files, without the leading capital “C”.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>modules/user/index.js
modules/user/meta_inf.json
modules/database/index.js
modules/database/drivers/cassandra.js
modules/database/drivers/redis.js
package.json
</code></pre>
</div>

<p>The reason why the whole command is wrapped in <code class="highlighter-rouge">$()</code> is because we need to interpret that command and pass its output to our <code class="highlighter-rouge">subl</code> executable, which is actually a command line shortcut to open Sublime Text. The end result is that we get all the conflicted files open in tabs, in Sublime Text. We can now proceed to the conflict resolution part, which I will not detail here.</p>

<p>After resolving the conflicts in your editor and saving the edits you made, you will notice that if you issue the <code class="highlighter-rouge">svn st | grep "^C"</code> command, you’ll still see the files as being in a conflicted state. This is because SVN creates separate files for each side of the conflict and refers to them when it shows a file as conflicted, and they look like the output below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>C       modules/user/index.js
?       modules/user/index.js.merge-left.r10231
?       modules/user/index.js.merge-right.r10255
?       modules/user/index.js.working
C       modules/user/meta_inf.json
?       modules/user/meta_inf.json.merge-left.r10231
?       modules/user/meta_inf.json.merge-right.r10255
?       modules/user/meta_inf.json.working
<span class="o">[</span>...]
</code></pre>
</div>

<p>The next step would be to manually remove those files, and we’re going to rely on awk again, for this task. Remember how we used <code class="highlighter-rouge">print</code> to pipe only the filenames to Sublime Text? That’s exactly what we are going to do now, but we’ll add <code class="highlighter-rouge">.*</code> at the end of each file, as we only want to remove the <code class="highlighter-rouge">.merge* </code> and the <code class="highlighter-rouge">.working</code> files, and not our original source code, and we will pipe everything to <code class="highlighter-rouge">rm</code>.</p>

<p><code class="highlighter-rouge">&gt; rm -Rf $(svn st | grep "^C" | awk '{print $2".*"}')</code></p>

<p>And you’re done, you can now commit your changes!</p>

<blockquote>
  <p>Image credits: <a href="https://flic.kr/p/6AMV1C">Owl</a> by <a href="https://www.flickr.com/photos/23975018@N04/">DIVA007</a></p>
</blockquote>

  </main>

  <footer>
    <section>
	<h3>Spread the word</h3>
	<span class='st_facebook_large' displayText='Facebook'></span>
	<span class='st_twitter_large' displayText='Tweet'></span>
	<span class='st_linkedin_large' displayText='LinkedIn'></span>
	<span class='st_email_large' displayText='Email'></span>
	<span class='st_reddit_large' displayText='Reddit'></span>
	<span class='st_googleplus_large' displayText='Google +'></span>
	<span class='st_pinterest_large' displayText='Pinterest'></span>
</section>
    <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'codesinz'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  </footer>
</article>
